package siga

import (
	"bytes"
	"testing"
)

func TestForZipInputStream_LocalNoDescriptor_Unmodified(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	header := []byte{
		0x50, 0x4b, 0x03, 0x04,
		0x00, 0x00,
		0x00, 0x00, // No data descriptor flag.
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x63, 0xf3, 0xf3, 0xad,
		0x04, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
		0x04, 0x00,
		0x00, 0x00,
		't', 'e', 's', 't',
		'd', 'a', 't', 'a',
	}

	// when
	_, err := zis.Write(header)

	// then
	if err != nil {
		t.Fatal("unexpected error:", err)
	}
	if !bytes.Equal(header, out.Bytes()) {
		t.Errorf("header was modified:\n     got: %x\nexpected: %x", out.Bytes(), header)
	}
}

func TestForZipInputStream_LocalDescriptorDeflate_Unmodified(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	header := []byte{
		0x50, 0x4b, 0x03, 0x04,
		0x00, 0x00,
		0x08, 0x00, // Data descriptor flag.
		0x08, 0x00, // DEFLATE compression.
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00,
		0x00, 0x00,
		't', 'e', 's', 't',
		0x4b, 0x49, 0x2c, 0x49, 0x04, 0x00,
		0x50, 0x4b, 0x07, 0x08,
		0x63, 0xf3, 0xf3, 0xad,
		0x06, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
	}

	// when
	_, err := zis.Write(header)

	// then
	if err != nil {
		t.Fatal("unexpected error:", err)
	}
	if !bytes.Equal(header, out.Bytes()) {
		t.Errorf("header was modified:\n     got: %x\nexpected: %x", out.Bytes(), header)
	}
}

func TestForZipInputStream_LocalDescriptorStoreMimetype_DescriptorRemoved(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	with := []byte{
		0x50, 0x4b, 0x03, 0x04,
		0x00, 0x00,
		0x08, 0x00, // Data descriptor flag.
		0x00, 0x00, // No compression.
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x08, 0x00,
		0x00, 0x00,
		'm', 'i', 'm', 'e', 't', 'y', 'p', 'e',
		'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', '/',
		'v', 'n', 'd', '.', 'e', 't', 's', 'i', '.',
		'a', 's', 'i', 'c', '-', 'e', '+', 'z', 'i', 'p',
		0x50, 0x4b, 0x07, 0x08,
		0x8a, 0x21, 0xf9, 0x45,
		0x1f, 0x00, 0x00, 0x00,
		0x1f, 0x00, 0x00, 0x00,
	}
	without := []byte{
		0x50, 0x4b, 0x03, 0x04,
		0x00, 0x00,
		0x00, 0x00, // No data descriptor flag.
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x8a, 0x21, 0xf9, 0x45, // Values from data descriptor.
		0x1f, 0x00, 0x00, 0x00,
		0x1f, 0x00, 0x00, 0x00,
		0x08, 0x00,
		0x00, 0x00,
		'm', 'i', 'm', 'e', 't', 'y', 'p', 'e',
		'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', '/',
		'v', 'n', 'd', '.', 'e', 't', 's', 'i', '.',
		'a', 's', 'i', 'c', '-', 'e', '+', 'z', 'i', 'p',
		// No data descriptor.
	}

	// when
	_, err := zis.Write(with)

	// then
	if err != nil {
		t.Fatal("unexpected error:", err)
	}
	if !bytes.Equal(without, out.Bytes()) {
		t.Errorf("unexpected header:\n     got: %x\nexpected: %x", out.Bytes(), without)
	}
}

func TestForZipInputStream_LocalDescriptorStoreOther_Error(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	header := []byte{
		0x50, 0x4b, 0x03, 0x04,
		0x00, 0x00,
		0x08, 0x00, // Data descriptor flag.
		0x00, 0x00, // No compression.
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00,
		0x00, 0x00,
		't', 'e', 's', 't',
		'd', 'a', 't', 'a',
		0x50, 0x4b, 0x07, 0x08,
		0x63, 0xf3, 0xf3, 0xad,
		0x04, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
	}

	// when
	_, err := zis.Write(header)

	// then
	if err == nil {
		t.Fatal("unexpected success")
	}
}

func TestForZipInputStream_LocalDescriptorStoreMimetypeSecond_Error(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	zis.(*zipInputStream).written = 1
	header := []byte{
		0x50, 0x4b, 0x03, 0x04,
		0x00, 0x00,
		0x08, 0x00, // Data descriptor flag.
		0x00, 0x00, // No compression.
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x08, 0x00,
		0x00, 0x00,
		'm', 'i', 'm', 'e', 't', 'y', 'p', 'e',
		'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', '/',
		'v', 'n', 'd', '.', 'e', 't', 's', 'i', '.',
		'a', 's', 'i', 'c', '-', 'e', '+', 'z', 'i', 'p',
		0x50, 0x4b, 0x07, 0x08,
		0x8a, 0x21, 0xf9, 0x45,
		0x1f, 0x00, 0x00, 0x00,
		0x1f, 0x00, 0x00, 0x00,
	}

	// when
	_, err := zis.Write(header)

	// then
	if err == nil {
		t.Fatal("unexpected success")
	}
}

func TestForZipInputStream_CentralOffsetZero_Unmodified(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	zis.(*zipInputStream).recalc = true
	header := []byte{
		0x50, 0x4b, 0x01, 0x02,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, // Relative offset 0.
		't', 'e', 's', 't',
	}

	// when
	_, err := zis.Write(header)

	// then
	if err != nil {
		t.Fatal("unexpected error:", err)
	}
	if !bytes.Equal(header, out.Bytes()) {
		t.Errorf("header was modified:\n     got: %x\nexpected: %x", out.Bytes(), header)
	}
}

func TestForZipInputStream_CentralOffsetNonZero_Recalculated(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	zis.(*zipInputStream).recalc = true
	original := []byte{
		0x50, 0x4b, 0x01, 0x02,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, // Relative offset 32.
		't', 'e', 's', 't',
	}
	recalc := []byte{
		0x50, 0x4b, 0x01, 0x02,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x10, 0x00, 0x00, 0x00, // Relative offset 16.
		't', 'e', 's', 't',
	}

	// when
	_, err := zis.Write(original)

	// then
	if err != nil {
		t.Fatal("unexpected error:", err)
	}
	if !bytes.Equal(recalc, out.Bytes()) {
		t.Errorf("unexpected header:\n     got: %x\nexpected: %x", out.Bytes(), recalc)
	}
}

func TestForZipInputStream_EOCD_Recalculated(t *testing.T) {
	// given
	var out bytes.Buffer
	zis := forZipInputStream(&out)
	zis.(*zipInputStream).recalc = true
	original := []byte{
		0x50, 0x4b, 0x05, 0x06,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, // Central directory offset 32.
		0x00, 0x00,
	}
	recalc := []byte{
		0x50, 0x4b, 0x05, 0x06,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x10, 0x00, 0x00, 0x00, // Central directory offset 16.
		0x00, 0x00,
	}

	// when
	_, err := zis.Write(original)

	// then
	if err != nil {
		t.Fatal("unexpected error:", err)
	}
	if !bytes.Equal(recalc, out.Bytes()) {
		t.Errorf("unexpected header:\n     got: %x\nexpected: %x", out.Bytes(), recalc)
	}
}
